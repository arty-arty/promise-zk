mod utils;

use ark_bn254::{Bn254, Fq, Fq2, Fr, G1Affine, G2Affine};
use ark_groth16::{prepare_verifying_key, Groth16, PreparedVerifyingKey, Proof, VerifyingKey};
use fastcrypto_zkp::bn254::api::{prepare_pvk_bytes, verify_groth16_in_bytes};

use utils::set_panic_hook;
use wasm_bindgen::prelude::*;
//use ark_serialize::{CanonicalSerialize, CanonicalDeserialize};
use ark_serialize::*;
//use ark_test_curves::BigInt;
use num_bigint::BigUint;
use serde_json::{Number, Value};
use serde_wasm_bindgen;
use std::str::FromStr;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
}

fn fq_from_arr(arr: Vec<Value>) -> Vec<Fq> {
    let mut result: Vec<Fq> = Vec::new();
    for entry in arr {
        result.push(Fq::from(
            BigUint::from_str(entry.as_str().unwrap()).unwrap(),
        ))
    }
    result
}

fn decode_g1(val: &Value) -> G1Affine {
    let arr = val.as_array().unwrap().to_vec();
    let bigs = fq_from_arr(arr);

    let result: G1Affine = G1Affine::new(bigs[0], bigs[1]);
    result
}

fn decode_g2(val: &Value) -> G2Affine {
    let arr = val.as_array().unwrap().to_vec();
    let x_fq = fq_from_arr(arr[0].as_array().unwrap().to_vec());
    let y_fq = fq_from_arr(arr[1].as_array().unwrap().to_vec());

    let x = Fq2::new(x_fq[0], x_fq[1]);
    let y = Fq2::new(y_fq[0], y_fq[1]);

    let result: G2Affine = G2Affine::new(x, y);
    result
}

fn decode_ics(ics: &Vec<Value>) -> Vec<G1Affine> {
    let mut gamma_abc_g1: Vec<G1Affine> = Vec::new();
    for ic in ics {
        let tmp = decode_g1(ic);
        gamma_abc_g1.push(tmp);
    }
    gamma_abc_g1
}

#[wasm_bindgen]
pub fn greet() -> u64 {
    set_panic_hook();
    return 48;
}

#[wasm_bindgen]
pub fn vkey_serialize(vkey: String) -> String {
    //Assumes vkey is a json representation of a vkey generated by snarkjs
    let vkey_json = serde_json::from_str::<Value>(&vkey).unwrap();
    println!("{}", vkey_json);

    let alpha_g1: G1Affine = decode_g1(&vkey_json["vk_alpha_1"]);
    let beta_g2: G2Affine = decode_g2(&vkey_json["vk_beta_2"]);
    let gamma_g2: G2Affine = decode_g2(&vkey_json["vk_gamma_2"]);
    let delta_g2: G2Affine = decode_g2(&vkey_json["vk_delta_2"]);
    let gamma_abc_g1: Vec<G1Affine> = decode_ics(vkey_json["IC"].as_array().unwrap());

    let my_vk: VerifyingKey<Bn254> = VerifyingKey::<Bn254> {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };

    let mut compressed_bytes = Vec::new();
    my_vk.serialize_compressed(&mut compressed_bytes).unwrap();
    hex::encode(&compressed_bytes)
}

#[wasm_bindgen]
pub fn vkey_prepared_serialize(vkey: String) -> JsValue {
    let mut result = Vec::new();

    //Assumes vkey is a json representation of a vkey generated by snarkjs
    let vkey_json = serde_json::from_str::<Value>(&vkey).unwrap();
    println!("{}", vkey_json);

    let alpha_g1: G1Affine = decode_g1(&vkey_json["vk_alpha_1"]);
    let beta_g2: G2Affine = decode_g2(&vkey_json["vk_beta_2"]);
    let gamma_g2: G2Affine = decode_g2(&vkey_json["vk_gamma_2"]);
    let delta_g2: G2Affine = decode_g2(&vkey_json["vk_delta_2"]);
    let gamma_abc_g1: Vec<G1Affine> = decode_ics(vkey_json["IC"].as_array().unwrap());

    let my_vk: VerifyingKey<Bn254> = VerifyingKey::<Bn254> {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };

    let mut compressed_bytes = Vec::new();
    my_vk.serialize_compressed(&mut compressed_bytes).unwrap();

    let pvk = prepare_pvk_bytes(&compressed_bytes).unwrap();

    result.push(hex::encode(&pvk[0]));
    result.push(hex::encode(&pvk[1]));
    result.push(hex::encode(&pvk[2]));
    result.push(hex::encode(&pvk[3]));
    serde_wasm_bindgen::to_value(&result).unwrap()
}

#[wasm_bindgen]
pub fn proof_serialize(proof: String) -> String {
    let proof_json = serde_json::from_str::<Value>(&proof).unwrap();
    let pi_a: G1Affine = decode_g1(&proof_json["pi_a"]);
    let pi_b: G2Affine = decode_g2(&proof_json["pi_b"]);
    let pi_c: G1Affine = decode_g1(&proof_json["pi_c"]);
    let my_proof: Proof<Bn254> = Proof::<Bn254> {
        a: pi_a,
        b: pi_b,
        c: pi_c,
    };
    let mut compressed_bytes = Vec::new();
    my_proof
        .serialize_compressed(&mut compressed_bytes)
        .unwrap();
    hex::encode(&compressed_bytes)
}

#[wasm_bindgen]
pub fn public_input_serialize(public_input: String) -> String {
    //let my_public_inputs: [Fr; 2] = [Fr::from(385), Fr::from(5)];
    let mut compressed_input1: Vec<u8> = Vec::new();
    //let mut compressed_input2: Vec<u8> = Vec::new();

   
    let big_int_public = BigUint::from_str(&public_input).unwrap();
    Fr::from(big_int_public)
        .serialize_compressed(&mut compressed_input1)
        .unwrap();

    let compressed_public_inputs: Vec<u8> = [compressed_input1].concat();
    hex::encode(&compressed_public_inputs)
}
